//---------------------------------------------------------------------------
//
//  УЧЕБНЫЙ ПРОЕКТ
//  АРИФМЕТИЧЕСКИЕ, ЛОГИЧЕСКИЕ ОПЕРАЦИИ. ПОСТРОЕНИЕ ГРАФИКОВ ФУНКЦИЙ.
//  Графические построения: на дисплее отладочной платы, 
//                          в режиме симуляции - средствами среды.
//  Copyright (C) 2016 МИРЭА
//
//---------------------------------------------------------------------------
/*  
    ОСНОВНЫЕ ОПЕРАЦИИ

    Компиляция проекта:           клавиша F7      (кнопка Build или меню Project/Build)
    Вход в режим отладки:         клавиша Ctrl+F5 (кнопка или меню Debug/Start/Stop Debug Session)
    Вставка точки останова:       клавиша F9      (кнопка или меню Debug/Insert/Remove Breakpoint)
    Шаговое выполнение с заходом
      в вызываемые функции:       клавиша F11     (кнопка Step или пункт меню Debug/Step)
    Шаговое выполнение без захода
      в вызываемые функции:       клавиша F10     (кнопка Step Over или пункт меню Debug/Step Over)
    Непрерывное выполнение:       клавиша F5      (кнопка Run или пункт меню Debug/Run)
    Возврат из режима отладки:    клавиша Ctrl+F5 (кнопка или меню Debug/Start/Stop Debug Session)

    
    ПОРЯДОК ВИЗУАЛИЗАЦИИ ГРАФИКА ФУНКЦИИ
  
    Откомпилировать проект (F7).
    Инициировать режим отладки (Ctrl+F5).
    Поставить точку остановки на последний оператор - while(1) - должна присутствовать красная метка слева.
    Открыть логический анализатор: меню  View / Analysis Windows / Logic Analyzer.
    Если левое поле анализатора пусто, в тексте программы последовательно выделить имена
    Data1, Data2, Data3 и перетащить их на это поле анализатора.
    Запустить программу на выполнение (F5).
    После остановки отрегулировать масштаб диаграмм полем Zoom (In/Out/All).
    Возвратиться из отладочного режима (Ctrl+F5).
*/
//---------------------------------------------------------------------------
// Заголовочные файлы
#include <stdint.h>                     //Объявления типов данных
#include <math.h>                       //Функции стандартной библиотеки C/C++
#include "arm_math.h"                   //Функции стандартной библиотеки CMSIS
#include "lcd.h"                        //Функции работы с дисплеем
#include "values.h"                     //Числовые значения для операндов 
#ifndef SIMUL
#include "stm32_p407.h"                 //Файл конфигурации отладочной платы STM32-P407
#endif                                  // (обходится при компиляции в режиме симуляции)
 
// Прототипы вызываемых функций
int16_t func(float arg);                                         //В этом файле
void LCD_DiagramDraw(short* Samples, int begindex, int length);  //В файле diagr.c

// Глобальные параметры (доступны всем подпрограммам и другим модулям программы)
#define NBuf    1000                    //Длина буфера данных (константа)
int16_t BufData[NBuf];                  //Буфер данных (массив размером NBuf 16-разрядных элементов)
int16_t Data1, Data2, Data3;            //Текущие значения функций
int8_t  y1, y2;                         //Промежуточные значения
int16_t y3;
int dIndex, dLength, dMin;              //Параметры для построения диаграммы

//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ
// Имеет стандартное имя: main.
// При запуске программы управление передается на первый оператор этой функции.
// Главная функция не должна иметь выхода.
int main()
{
  //Объявление локальных переменных
  int i;                          //Счетчик цикла
  int8_t x1, x2, x3, x4;          //8-битные операнды
  float ampl1 = 0.2;              //Амплитуда для функции 1
  float ampl2 = 0.8;              //Амплитуда для функции 2
  float arg1 = 0, arg2 = 0;       //Начальные значения аргументов функций
                // 1 вариант: задание шага изменения аргумента (используется для периодических функций) 
  float step1 = PI/11,            //Величины приращений аргументов, где PI = 3.141592...
        step2 = PI/110;           // (операцию деления здесь осуществляет компилятор)
                // 2 вариант: задание минимального и максимального значений аргумента 
  //float arg1_min = 0, arg1_max = 90*PI,
  //      arg2_min = 0, arg2_max = 9*PI;
  
  //Присвоение начальных значений 8-битным операндам
  x1 = 0x12;                      //Константа в 16-ричной системе
  x2 = -34;                       //Константа в 10-ричной системе
  x3 = value1;                    //Значения, заданные в заголовочном файле
  x4 = value2;

  //Примеры записи арифметических и логических операций
  y1 = x1 + x2;                   //Сложение
  y2 = x3 - x4;                   //Вычитание
  y3 = y1 * y2;                   //Умножение
  y1 = y3 / x3;                   //Целочисленное деление
  y2 = y3 % x3;                   //Остаток от деления
  
  x2 = ~x2;                       //НЕ, инверсия
  y1 = x2 & x4;                   //И, логическое умножение, конъюнкция
  y2 = x1 | x3;                   //ИЛИ, логическое сложение, дизъюнкция
  y2 = y2 ^ y1;                   //Исключающее ИЛИ, сложение по модулю 2, неравнозначность

  //Цикл вычисления функций
  for (i = 0; i < NBuf; i++)      //Счетчик (i) меняется от 0 до NBuf-1 с шагом 1
  {
    //:::::: Начало одного цикла вычислений :::::::::::::::::::::::::::::::::

    if (i < NBuf/4 || (i >= NBuf/2 && i < NBuf*3/4)) //Ветление по 4 интервалам изменения аргумента
    { Data1 = ampl1 * func(arg1); //Функция 1 от аргумента 1
      Data2 = ampl2 * func(arg2); //Функция 2 от аргумента 2
    }  
    else
    { Data1 = ampl2 * func(arg1); //Функция 1 от аргумента 1
      Data2 = ampl1 * func(arg2); //Функция 2 от аргумента 2
    }  
    Data3 = Data1 + Data2;        //Функция 3 как сумма функций 1 и 2

                // 1 вариант: приращение аргумента на заданный шаг
    arg1 += step1;                //Изменение аргумента 1
    arg2 += step2;                //Изменение аргумента 2
                // 2 вариант: вычисление аргумента по текущему номеру отсчета
    //arg1 = arg1_min + (arg1_max - arg1_min) * i / NBuf;
    //arg2 = arg2_min + (arg2_max - arg2_min) * i / NBuf;

    //:::::: Конец одного цикла вычислений ::::::::::::::::::::::::::::::::::
    
    BufData[i] = Data3;           //Сохранение значения функции 3 в буфере
  }

  //Следующий фрагмент, ограниченный директивами условной компиляции (#if.. #else),
  // компилируется только для режима симуляции (Project: simulator) 
#ifdef SIMUL                      //========================================================

  while (1);                      //Остановка выполнения: оператор представляет собой
                                  // бесконечный цикл, не позволяющий выйти из функции main

#else                             //========================================================
  //Следующий фрагмент, ограниченный директивами условной компиляции (#else..#endif),
  // компилируется только для отладочной платы (Project: board)
  
  //Инициализация кнопок и джойстика
  STM_PBInit(BUTTON_TAMPER, BUTTON_MODE_GPIO);  //Кнопка TAMPER (здесь не используется)
  STM_PBInit(BUTTON_WAKEUP, BUTTON_MODE_GPIO);  //Кнопка  WAKEUP (для завершения программы)
  STM_PBInit(BUTTON_RIGHT, BUTTON_MODE_GPIO);   //Позиции джойстика
  STM_PBInit(BUTTON_LEFT, BUTTON_MODE_GPIO);    // - " -
  STM_PBInit(BUTTON_UP, BUTTON_MODE_GPIO);      // - " -
  STM_PBInit(BUTTON_DOWN, BUTTON_MODE_GPIO);    // - " -
  STM_PBInit(BUTTON_SEL, BUTTON_MODE_GPIO);     // - " -
  
  //Инициализация дисплея
  LCD_Init();

  //Значения по умолчанию для вывода диаграммы
  dIndex = 0;                                   //Начальный номер отсчета
  dMin = 15;                                    //Минимальное число отсчетов
  dLength = dMin*8;                             //Текущее число отсчетов

  //Начальное построение диаграммы на дисплее
  LCD_DiagramDraw(BufData, dIndex, dLength);
  
  //Бесконечный цикл в основной программе
  while (true)
  {
    //Проверка положения джойстика "Влево" и возможности смещения диаграммы к началу
    if (STM_PBGetState(BUTTON_LEFT) && dIndex > 0)
    { if (dIndex - dLength > 0) dIndex -= dLength;
      else dIndex = 0;
      LCD_DiagramDraw(BufData, dIndex, dLength);
      while (STM_PBGetState(BUTTON_LEFT));      //Ожидание отпускания кнопки
    }
    //Проверка положения джойстика "Вправо" и возможности смещения диаграммы к концу
    if (STM_PBGetState(BUTTON_RIGHT) && dIndex + dLength < NBuf)
    { if (dIndex + dLength*2 < NBuf) dIndex += dLength;
      else dIndex = NBuf - dLength;
      LCD_DiagramDraw(BufData, dIndex, dLength);
      while (STM_PBGetState(BUTTON_RIGHT));
    }
    //Проверка положения джойстика "Вверх" и возможности раздвижки диаграммы
    if (STM_PBGetState(BUTTON_UP) && dLength > dMin)
    { dLength /= 2;
      LCD_DiagramDraw(BufData, dIndex, dLength);
      while (STM_PBGetState(BUTTON_UP));
    }
    //Проверка положения джойстика "Вниз" и возможности сдвижки диаграммы
    if (STM_PBGetState(BUTTON_DOWN) && dLength < NBuf/2)
    { dLength *= 2;
      if (dIndex + dLength > NBuf) dIndex = NBuf - dLength;
      LCD_DiagramDraw(BufData, dIndex, dLength);
      while (STM_PBGetState(BUTTON_DOWN));
    }

    //Проверка воздействия на кнопку WAKEUP, при нажатии - сброс, эквивалентный
    //  нажатию кнопки RESET (здесь - завершение данной программы)
    if (STM_PBGetState(BUTTON_WAKEUP)) NVIC_SystemReset();
  }
  
#endif      //Конец компиляции операторов работы с отладочной платой
}

//---------------------------------------------------------------------------
// ФУНКЦИЯ
// Обратите внимание, что аргумент arg - вещественное число (с плавающей точкой),
// значение же функции приводится к целочисленному 16-разрядному значению
int16_t func(float arg)
{  
  return sinf(arg) * 32767;
}
//---------------------------------------------------------------------------
