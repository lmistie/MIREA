//---------------------------------------------------------------------------
// 
//  ДЕМОНСТРАЦИОННЫЙ ПРОЕКТ
//
//  Сигнализатор (вариант 3)
//  Задание: при нажатии кнопки сформировать звуковой сигнал с частотой 1 кГц и
//  длительностью 2 с. Светодиодный индикатор должен включаться на время
//  звукового сигнала и мигать остальное время. 
//
//  Выходной сигнал формируется посредством ЦАП.
//  Генерация частоты дискретизации, отработка временных интервалов производятся 
//  с помощью таймеров. При опросе кнопки, работе ЦАП и таймеров используется 
//  система прерываний.
//  Демонстрируется применение отладочного вывода: сигнал в обработчике таймера
//  периода дискретизации позволяет контролировать величину периода дискретизации
//  и время, затраченное на вычисление и вывод отсчета генерируемого сигнала.
//
//  Copyright (C) 2013 МГТУ МИРЭА
//
//---------------------------------------------------------------------------

#include "stm32f4xx.h"                  //Константы и структуры данных для процессоров семейства STM32F4xx
#include "stm32_ports.h"                //Функции работы с портами
#include "math.h"                       //Математические функции стандартной библиотеки C/C++
#include "arm_math.h"                   //Функции стандартной библиотеки CMSIS

#define SAMPLE_NUMBER    16000*2        //Число отсчетов выводимого сигнала:
                                        // (частота дискретизации * длительность)
#define WAIT_IND_PERIOD  1000           //Периодичность переключения индикатора в режиме ожидания, мс
#define WAIT_IND_ON        10           //Длительность включенного состояния индикатора в режиме ожидания, мс
#define GEN_IND_PERIOD    100           //Периодичность переключения индикатора в режиме генерации, мс
#define GEN_IND_ON         60           //Длительность включенного состояния индикатора в режиме генерации, мс

void TimerDiscretConfig(void);          //Прототипы функций, определены в файле timer.c
void TimerDiscretInterrupt(bool NewState);
void DACConfig(void);
void TimerIndicatorConfig(void);

int SampleCounter = 0;                  //Счетчик выводимых отсчетов, при 0 - нет генерации сигнала
bool IndicatorOn;                       //Флаг состояния индикатора: 1 - включен, 0 - выключен

//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ 
int main()
{
  //Инициализация разрядов порта с органами управления:
  // основная кнопка (TAMPER) - подключена к разряду 13 порта PC, подтянута к '1', замыкает на '0',
  //                            конфигурируется для прерываний по спадающему фронту
  PortInputInit(GPIOC, GPIO_Pin_13, GPIO_PuPd_UP, EXTI_Trigger_Falling);
  // отладочная кнопка (WAKEUP) - подключена к разряду 0 порта PA, подтянута к '0', замыкает на '1'
  PortInputInit(GPIOA, GPIO_Pin_0, GPIO_PuPd_DOWN, 0);

  //Инициализация разряда 6 порта PF с индикатором (включение индикатора - лог. '1')
  PortOutputInit(GPIOF, GPIO_Pin_6);
  //Инициализация разряда 9 порта PF для контрольного (отладочного) вывода 
  PortOutputInit(GPIOF, GPIO_Pin_9);

  //Инициализация ЦАП
  DACConfig();

  //Инициализация таймера - источника частоты дискретизации,
  // конфигурирование и разрешение прерывания от источника частоты дискретизации
  TimerDiscretConfig();
  TimerDiscretInterrupt(true);
  
  //Инициализация таймера-формирователя временных задержек для индикации,
  // конфигурирование прерывания от таймера  
  TimerIndicatorConfig();
  
  //Основной цикл
  while (1)
  {
    __WFI();                                    //Режим пониженного энергопотребления (Sleep)
  
    //Управление индикатором
    PortWriteBit(GPIOF, GPIO_Pin_6, IndicatorOn);

    //Отладочный оператор:
    // если нажата отладочная кнопка, сброс процессора - выход из программы 
    if (PortReadBit(GPIOA, GPIO_Pin_0)) NVIC_SystemReset();
  }
}

//---------------------------------------------------------------------------
// ФОРМИРОВАНИЕ ОТСЧЕТОВ СИГНАЛА
int sin_index;
int16_t SinTable[16] = { 0,  12539,  23170,  30273,  32767,  30273,  23170,  12539,
                         0, -12539, -23170, -30273, -32767, -30273, -23170, -12539 };
int16_t GetSample(void)
{
  sin_index = sin_index + 1 & 0xF;              //Изменение индекса: 0, 1, ..., 15, 0, 1, ...
  return sinf(2*PI*sin_index/16) * 0x7FFF;      //Вариант с вычислением функции для каждого отсчета
//return SinTable[sin_index];                   //Вариант с выборкой отсчетов из таблицы
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ ТАЙМЕРА ПЕРИОДА ДИСКРЕТИЗАЦИИ
// Вызывается с частотой дискретизации.
// Проверяется флаг типа прерывания (в данном случае это необязательно, так как используется один тип),
// флаг очищается, формируется код и передается в ЦАП (ЦАП работает в смещенном коде).
void TIM4_IRQHandler(void)
{
  int16_t Sample;
  PortWriteBit(GPIOF, GPIO_Pin_9, 1);                   //Передний фронт отладочного импульса
  if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)    //Проверка флага запроса прерывания
  {
    TIM_ClearITPendingBit(TIM4, TIM_IT_Update);         //Сброс флага
    if (SampleCounter != 0)                             //Проверка на необходимость формирования сигнала 
    { SampleCounter--;                                  //Счетчик оставшихся для вывода отсчетов
      Sample = GetSample()/2;                           //Получение отсчета (в дополнительном
    }                                                   // коде со знаком), уменьшение амплитуды 
    else                                                // для предотвращения перегрузки
      Sample = 0;                                       //Если сигнала нет, задание нулевой амплитуды
    //Преобразование значения отсчета из дополнительного кода в смещенный и передача
    //  в 12-разрядный ЦАП с выравниванием влево
    DAC_SetChannel1Data(DAC_Align_12b_L, (uint16_t)(Sample ^ 0x8000));
  }
  PortWriteBit(GPIOF, GPIO_Pin_9, 0);                   //Задний фронт отладочного импульса
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ ВНЕШНЕГО СИГНАЛА - КНОПКИ
// В основной программе прерывание было сконфигурировано для внешней линии EXTI_Line13
// (кнопка подключена к разряду 13 порта). Данный обработчик является общим для линий
// EXTI_Line10... EXTI_Line15. 
// При обработке проверяется и очищается флаг запроса, разрешается формирование сигнала
// (загрузкой счетчика числа отсчетов), перезагружается таймер управления индикацией.
void EXTI15_10_IRQHandler(void)
{
  if (EXTI_GetITStatus(EXTI_Line13) != RESET)           //Проверка флага запроса прерывания
  {
    EXTI_ClearITPendingBit(EXTI_Line13);                //Очистка флага
    SampleCounter = SAMPLE_NUMBER;                      //Загрузка счетчика отсчетов - является
                                                        // также разрешением на выдачу сигнала
    TIM_SetCounter(TIM10, 0);                           //Перезагрузка таймера управления индикацией
    TIM_GenerateEvent(TIM10, TIM_IT_Update);            //Программная генерация прерывания от таймера
  }  
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ ТАЙМЕРА - ФОРМИРОВАТЕЛЯ ВРЕМЕННЫХ ИНТЕРВАЛОВ ДЛЯ ИНДИКАЦИИ
// Обработчик вызывается, когда в таймере произошло переполнение и автоперезагрузка
// его счетчика, т.е. когда закончился заданный временной интервал.
// Здесь проверяется флаг запроса, флаг сбрасывается. Далее, в зависимости от режима -
// генерация сигнала или ожидание, а также от того, в каком состоянии находился
// индикатор, таймер загружается одним из 4-х новых значений для следующего временного интервала.
// Также изменяется флаг состояния индикатора. Реально переключение индикатора осуществляется
// в основной программе.
void TIM1_UP_TIM10_IRQHandler(void)
{
  if (TIM_GetITStatus(TIM10, TIM_IT_Update) != RESET)   //Проверка флага запроса прерывания
  {
    TIM_ClearITPendingBit(TIM10, TIM_IT_Update);        //Очистка флага
    if (SampleCounter)                                  //Если идет генерация сигнала
      if (IndicatorOn) TIM_SetAutoreload(TIM10, (GEN_IND_PERIOD - GEN_IND_ON) * 10);
      else TIM_SetAutoreload(TIM10, GEN_IND_ON * 10);
    else                                                //Режим ожидания
      if (IndicatorOn) TIM_SetAutoreload(TIM10, (WAIT_IND_PERIOD - WAIT_IND_ON) * 10);
      else TIM_SetAutoreload(TIM10, WAIT_IND_ON * 10);
    IndicatorOn = !IndicatorOn;                         //Изменение состояния индикатора
  }
}

//---------- Конец файла main3.c --------------------------------------------
