//---------------------------------------------------------------------------
// 
//  УЧЕБНЫЙ ПРОЕКТ ДЛЯ ПРАКТИЧЕСКИХ ЗАНЯТИЙ
//  Управление индикацией
//  Copyright (C) 2017 МИРЭА
//
//  Клавиши S1, S2 включают/выключают соответственно индикаторы LED1, LED2. 
//  Переключатель S3 задает два уровня яркости свечения (максимальный, средний).
//
//  Используемые разряды портов: 
//  S1 подключено к PA2  (исх. уровень "1", при нажатии - "0"),
//  S2 подключено к PA9  (исх. уровень "0", при нажатии - "1"),
//  S3 подключено к PA15 (исх. уровень "1", при нажатии - "0"),
//  LED1 подключено к PB5, LED2 - к PB7 (для включения необходим уровень "0").
//
//  В данном проекте продемонстрирован прием обращения к устройствам ввода-вывода в режиме
//  симуляции и отладки.
//
//  Каждый порт представляет собой набор регистров, начальный адрес которых задается
//  константой GPIOx (где x - A, B, C, ... - обозначение порта). Набор регистров программно
//  организован в виде структуры, объявленной в заголовочном файле stm32f4xx.h:
//  typedef struct
//  {
//    __IO uint32_t MODER;    /* Регистр режимов работы порта (вход/выход) */
//    __IO uint32_t OTYPER;   /* Регистр задания типа выходного каскада */
//    __IO uint32_t OSPEEDR;  /* Регистр задания максимальной скорости вывода */
//    __IO uint32_t PUPDR;    /* Регистр конфигурирования подтягивающего резистора */
//    __IO uint32_t IDR;      /* Регистр входных данных */
//    __IO uint32_t ODR;      /* Регистр выходных данных */
//    __IO uint16_t BSRRL;    /* Регистр установки/сброса выходных бит, младшая часть (установка) */
//    __IO uint16_t BSRRH;    /* Регистр установки/сброса выходных бит, старшая часть (сброс) */
//    __IO uint32_t LCKR;     /* Регистр блокировки изменения конфигурации (до сброса процессора) */
//    __IO uint32_t AFR[2];   /* Регистры выбора альтернативной функции (по 4 бита на разряд) */
//  } GPIO_TypeDef;
//
//  Начальный адрес GPIOx является указателем на структуру, т.е. имеет тип (GPIO_TypeDef *)
//
//---------------------------------------------------------------------------

//#include <stdint.h>                   // Объявления типов данных (stdint.h включен в stm32f4xx.h)
#include <stdbool.h>
#include "stm32f4xx.h"                  // Объявления ресурсов процессоров семейства STM32F4xx
#include "stm32f4xx_gpio.h"             // Объявление констант и функций работы с портами

//---------------------------------------------------------------------------
// Библиотечные функции обращения к портам, реализованные в stm32f4xx_gpio.с,
// здесь временно представлены как заглушки. Тип данных BitAction объявлен как перечислимый
// тип: Bit_RESET (= 0), Bit_SET (= 1), по смыслу является булевым.
// Номера GPIO_Pin разрядов портов представляют собой маски:
// GPIO_Pin_0 - 0x0001, GPIO_Pin_1 - 0x0002, ..., GPIO_Pin_15 - 0x8000.
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx) { return 0; }
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) { return 0; }
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx) { return 0; }
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal) { }
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal) { }

// Подпрограмма инициализации портов, пока - заглушка
void PortInitialize() { }

// Подпрограмма временной задержки в мс (заглушка)
void Delay_ms(int ms) { }

//---------------------------------------------------------------------------
// Текущие константы
#define  t_on       1                   // Длительность включенного состояния индикатора, мс
#define  t_off      4                   // Длительность выключенного состояния индикатора, мс
#define  maskS1     0x0004              // = (1<<2)  Маска на разряд с номером 2 (клавиша S1)
#define  maskS2     0x0200              // = (1<<9)  Маска на разряд с номером 9 (клавиша S2)
#define  maskS3     0x8000              // = (1<<15) Маска на разряд с номером 15 (клавиша S3)

//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ
int main()
{
  //Текущие переменные
  uint16_t input, output;               // Входной и выходной коды

  PortInitialize();                     // Инициализация разрядов портов
                                        // (PA2, PA9, PA15 - на ввод, PB5, PB7 - на вывод)
  //Главный цикл программы
  while (true)
  {
    //Проверка состояния переключателя S3
    input = GPIO_ReadInputData(GPIOA);
    if (input & maskS3)
    //Режим максимальной яркости
    {
      /* Вариант 1. 
         Перепаковка входного кода: в переменной output в 5-м и 7-м разрядах формируются
         уровни для прямого вывода на индикаторы, а остальные разряды кода - нулевые.
         Далее вывод кода в порт. Это пример плохого варианта вывода, т.к. помимо необходимых
         разрядов, управляющих индикаторами, в порту производится изменение (в данном случае
         обнуление) всех остальных разрядов.
      */
      output = (input & maskS1) << 3 | (~input & maskS2) >> 2;
      GPIO_Write(GPIOB, output);

      /* Вариант 2
         Как и в варианте 1, перепаковка кода. Но перед выводом сначала считывается текущий
         выходной код, в нем изменяются только требуемые разряды (5-й и 7-й), и код 
         отправляется обратно в выходной порт.
      */
      output = (input & maskS1) << 3 | (~input & maskS2) >> 2;
      uint16_t outdata = GPIO_ReadOutputData(GPIOB);
      output = (outdata & ~0x00A0) | output;
      GPIO_Write(GPIOB, output);

      /* Вариант 3
         Самый оптимальный вариант, использующий обращение к определенным битам порта
         и не требующий перепаковки
      */
      GPIO_WriteBit(GPIOB, GPIO_Pin_5, (BitAction)(input & maskS1));
      GPIO_WriteBit(GPIOB, GPIO_Pin_7, (BitAction)(~input & maskS2));
      
    }
    //Режим пониженной яркости
    else
    {
      if ((input & maskS1) == 0) GPIO_WriteBit(GPIOB, GPIO_Pin_5, (BitAction)0);
      if ((input & maskS2) != 0) GPIO_WriteBit(GPIOB, GPIO_Pin_7, (BitAction)0);
      Delay_ms(t_on);
      GPIO_WriteBit(GPIOB, GPIO_Pin_5, (BitAction)1);
      GPIO_WriteBit(GPIOB, GPIO_Pin_7, (BitAction)1);
      Delay_ms(t_off);
    }
  }    
  
}

//---------------------------------------------------------------------------
