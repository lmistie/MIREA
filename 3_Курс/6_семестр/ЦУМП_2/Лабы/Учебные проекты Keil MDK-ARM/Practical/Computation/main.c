/*---------------------------------------------------------------------------
 * 
 *  УЧЕБНЫЙ ПРОЕКТ ДЛЯ ПРАКТИЧЕСКИХ ЗАНЯТИЙ
 *  Программирование вычислительных операций
 *  Copyright (C) 2017 МИРЭА
 *
 *  На вход устройства с квадратичной характеристикой y = x*x подается сигнал Uвх = Usm + Ua sin(wt).
 *  Характеристика имеет участок насыщения выше уровня Usat. Вычислить и сохранить три блока данных
 *  для трех значений напряжений Usm. Каждый блок содержит по 200 отсчетов на 2 периодах сигнала. 
 *  Привести выходные отсчеты к диапазону целочисленных 16-разрядных значений. 
 *  Вывести на печать число отсчетов, значения Usm и максимальные выходные амплитуды. 
 *
---------------------------------------------------------------------------*/
// Заголовочные файлы
#include <stdint.h>                     // Объявления типов данных
#include <math.h>                       // Функции стандартной библиотеки C/C++
#include "arm_math.h"                   // Функции стандартной библиотеки CMSIS
#include <stdio.h>                      // Функция printf
#define FLT_MAX  3.40282347e+38F        // Задание константы (объявлено в float.h)
 
// Прототип (объявление, декларация) вызываемой функции
float TransferFunc(float U1, float U2, float arg);

// Глобальные параметры (доступны всем подпрограммам и другим модулям программы)
#define Length           200            // Число точек одного блока данных
#define Block            3              // Число блоков данных
short ArraySamples[Length*Block];       // Буфер выходных данных
float Ua = 2.5;                         // Входная амплитуда переменной составляющей, В
float Usm[Block] = { 0, 7e-1, 2.5 };    // Массив напряжений смещения, В
float Usat = 12;                        // Уровень насыщения (ограничения) выходного напряжения, В
float wt1 = 0, wt2 = 4*PI;              // Диапазон значений (нач., кон.) аргумента функции sin
float X; short Y;                       // Отладочные параметры для возможного построения графика
                                        //  средствами среды разработки
//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ
int main()
{
  // Объявление локальных переменных
  int i, j;                             // Счетчики циклов по амплитудам и отсчетам
  float phase, u;                       // Текущие значения фазы и выходного напряжения
  float Umax[Block];                    // Максимумы

  // Цикл вычислений
  for (i = 0; i < Block; i++)           // Внешний цикл по индексам напряжений (i измен. от 0 до 2)
  { 
    Umax[i] = -FLT_MAX;                 // Начальное значение максимума равно минимально возможному
    for (j = 0; j < Length; j++)        // Вложенный цикл по отсчетам:
    {                                   //  счетчик j изменяется от 0 до Length-1 с шагом 1
      phase = wt1 + (wt2 - wt1) * j / Length;   //Вычисление текущей фазы
      u = TransferFunc(Usm[i], Ua, phase);      //Вызов функции
      if (u > Umax[i]) Umax[i] = u;             //Нахождение максимума
      ArraySamples[j + i*Length] = Y = (short)(u/Usat * 32767);
    }
  }  

  // Вывод результатов на стандартное устройство вывода (консоль, порт, дисплей)
  printf(" ===  РЕЗУЛЬТАТЫ === \r\n"
         "Число точек N = %d \r\n"
         "Смещение %.2f В, Макс. амплитуда = %g \r\n"
         "Смещение %.2f В, Макс. амплитуда = %g \r\n"
         "Смещение %.2f В, Макс. амплитуда = %g \r\n",
         Length, Usm[0], Umax[0], Usm[1], Umax[1], Usm[2], Umax[2]);
    
  while (1);                            // Остановка выполнения: оператор представляет собой
                                        //  бесконечный цикл, не позволяющий выйти из функции main
}

//---------------------------------------------------------------------------
// ФУНКЦИЯ (реализация, определение функции)
// Входные аргументы:
//   U1  - напряжение смещения
//   U2  - амплитуда переменной составляющей сигнала
//   arg - текущая фаза (аргумент синусоидальной функции)
// Возвращаемое значение: текущая выходная амплитуда
float TransferFunc(float U1, float U2, float arg)
{  
  float u;                              // Эта переменная не связана с переменной u в функции main
  u = powf (X = U1 + U2 * sinf(arg), 2);// Вычисление квадрата входной функции для текущей фазы
  if (u > Usat) u = Usat;               // Ограничение рассчитанного значения сверху
  else if (u < 0) u = 0;                //  и на всякий случай - снизу
  return u;                             // Возвращаемое значение 
}
//---------------------------------------------------------------------------
