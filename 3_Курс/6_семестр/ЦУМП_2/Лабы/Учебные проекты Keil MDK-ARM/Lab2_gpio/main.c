//---------------------------------------------------------------------------
// 
//  УЧЕБНЫЙ ПРОЕКТ
//  Конфигурирование, ввод-вывод через порты общего назначения
//  Copyright (C) 2016 МГТУ МИРЭА
//
//  Для работы с портом в заголовочном файле объявлена следующая структура 
//  typedef struct
//  {
//    __IO uint32_t MODER;    /* Регистр режимов работы порта (вход/выход) */
//    __IO uint32_t OTYPER;   /* Регистр задания типа выходного каскада */
//    __IO uint32_t OSPEEDR;  /* Регистр задания максимальной скорости вывода */
//    __IO uint32_t PUPDR;    /* Регистр конфигурирования подтягивающего резистора */
//    __IO uint32_t IDR;      /* Регистр входных данных */
//    __IO uint32_t ODR;      /* Регистр выходных данных */
//    __IO uint16_t BSRRL;    /* Регистр установки/сброса выходных бит, младшая часть (установка) */
//    __IO uint16_t BSRRH;    /* Регистр установки/сброса выходных бит, старшая часть (сброс) */
//    __IO uint32_t LCKR;     /* Регистр блокировки изменения конфигурации (до сброса процессора) */
//    __IO uint32_t AFR[2];   /* Регистры выбора альтернативной функции (по 4 бита на разряд) */
//  } GPIO_TypeDef;
//
//  В проекте иллюстрируется прямое обращение к регистрам. При этом требуется знание форматов
//  всех их полей (эта информация содержится в технической документации на процессор).
//  Другой вариант работы как с портами, так и с другими периферийными устройствами - 
//  применение библиотечных функций. Здесь этот прием показан на примере функции PB1_Init(),
//  он используется во всех остальных проектах лабораторного практикума.
//
//  Ввод из порта (чтение входных данных) осуществляется 16-разрядным словом. Вывод в порт
//  (запись выходных данных) через регистр ODR производится одновременно во все 16-разрядов,
//  а через регистры BSRRL, BSRRH возможна выборочная установка или сброс отдельных разрядов.
//
//  В проекте задействованы следующие внешние компоненты: 
//    - кнопкка TAMPER - подключена к разряду PC13, при нажатии замыкает на общий провод;
//    - кнопкка WAKEUP - подключена к разряду PA0, при нажатии замыкает на шину питания;
//    - джойстик с 4-мя позициями (LEFT, RIGHT, UP, DOWN) и кнопкой выбора (SEL):
//        контакт LEFT  подключен к разряду PG11, замыкает на шину питания;
//        контакт RIGHT подключен к разряду PG6,  замыкает на шину питания;
//        контакт UP    подключен к разряду PG7,  замыкает на шину питания;
//        контакт DOWN  подключен к разряду PG8,  замыкает на шину питания;
//        контакт SEL   подключен к разряду PG15, замыкает на шину питания;
//    - 4 светодиодных индикатора:
//        на выходном разряде PF6, обозначение на схеме/плате LED1 / STAT1 (левый)
//        на выходном разряде PF7, обозначение на схеме/плате LED2 / STAT2
//        на выходном разряде PF8, обозначение на схеме/плате LED3 / STAT3
//        на выходном разряде PF9, обозначение на схеме/плате LED4 / STAT4 (правый)
//    - звуковой излучатель, подключен к выходному разряду PB1.
//
//
//  Схема передачи уровней с кнопок джойстика на индикаторы, реализованная в данном проекте
//
//                                 0x200 0x100 0x80 0x40 - коды масок на соответствующие разряды  
//                                   LED4 LED3 LED2 LED1
//                                   +-+  +-+  +-+  +-+
//                                   | |  | |  | |  | |
//                                   +-+  +-+  +-+  +-+
//                                    |    |    |    | 
//   +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+  Выходной
//   | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  порт PF
//   +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+  (код indic)
//                                    ^    ^    ^    ^
//                                    |    |    |    |
//                          /---------|----|----|----/
//                          |         |    |    |  \_____ Сдвиг на 5 бит вправо (11 --> 6)
//                          |         |    |    |
//                          |         |    |    |   _____ Сдвиг на 3 бита влево (9 <-- 6)
//                          |         |    |    |  /
//                          |         \----|----|----\
//                          |              |    |    |
//                          |              |    |    |
//   +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+  Входной
//   | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  порт PG
//   +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+  (код joy)
//      |                   |              |    |    |
//     \                   \              \    \    \ 
//      |                   |              |    |    |
//      +                   +              +    +    +
//     SEL                LEFT           DOWN   UP  RIGHT
//   Маска на
//   разряд: 0x8000       \___/          \_______/  \___/
//                          |                |        |
//                     Будет сдвиг        Передача    Будет сдвиг на 3 бита влево
//                     на 5 бит вправо    без сдвига
//
//
//---------------------------------------------------------------------------

// Заголовочные файлы
#include "stm32_p407.h"                 //Файл конфигурации отладочной платы STM32-P407

// Библиотечные функции временных задержек
//  void Delay_ms(int ms);              //Входной аргумент: значение задержки в миллисекундах
//  void Delay_us(int us);              //Входной аргумент: значение задержки в микросекундах

//Прототипы функций, определенных в этом файле
void PB1_Init(void);

//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ 
int main()
{
  //Текущие переменные
  uint16_t joy, indic;                  //Код от джойстика, код для вывода на индикаторы
  int i = 0;                            //Счетчик

  // Разрешение тактирования используемых портов (A, C, F, G),
  // производится установкой бит в системном регистре AHB1ENR -
  // 0000 0000 0000 0000 0000 0000 0110 0101
  //                                ||   | |
  //                            KJIHGFE DCBA - обозначения портов
  RCC->AHB1ENR |= 0x65;

  // Конфигурирование разрядов портов A, C, G на ввод, разрядов 6, 7, 8, 9 порта F - на вывод.
  // В регистрах MODER каждые два бита определяют состояние соответствующего разряда порта:
  // 00 - ввод (по умолчанию),  01 - вывод, 10 - альтернативная функция, 11 - аналоговый вход
  //GPIOA->MODER = 0;   // \  Эти операторы можно опустить (значения заданы по умолчанию после сброса),
  GPIOC->MODER = 0;     //  | а при отладке с внутрисхемным эмулятором, который использует PA13, PA14,
  GPIOG->MODER = 0;     // /  такой способ конфигурирования для порта A является неправильным.
  GPIOF->MODER = 1 << 6*2 | 1 << 7*2 | 1 << 8*2 | 1 << 9*2;

  // Конфигурирование режимов работы разрядов портов:
  //   в регистре OSPEEDR: быстродействие на вывод - минимальное,
  //   в регистре OTYPER:  тип выходного каскада - двухтактный,
  //   в регистре PUPDR:   подтягивающий резистор - отсутствует (на плате установлены внешние).
  // Эти режимы заданы по умолчанию, поэтому никаких действий не предпринимаем.
  
  //Конфигурирование разряда PB1 на вывод посредством библиотечных функций 
  PB1_Init();
  
  //ГЛАВНЫЙ ЦИКЛ ПРОГРАММЫ
  while (1)
  {
    //Ввод 16-разрядного кода из порта G
    joy = GPIOG->IDR;

    //Перепаковка 4-х бит (смотри также схему выше):
    indic = (joy >> 5 & 0x40) |         // - сдвиг на 5 бит вправо и выделение 6-го разряда
            (joy & 0x180) |             // - без сдвига, выделение 7-го и 8-го разрядов
            (joy << 3 & 0x200);         // - сдвиг на 3 бита влево и выделение 9-го разряда

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    //Проверка 13-го разряда в порту C (т.е. кнопки TAMPER):
    // при отсутствии нажатия перепакованный код с кнопок постоянно передается в порт с индикаторами,
    // при нажатии - формируется последовательность: вывод кода, временная задержка, снятие кода,
    // временная задержка.
    if (GPIOC->IDR & 0x2000)
      GPIOF->ODR = indic;               //Если не нажата, вывод 16-разрядного кода в порт F (плохой пример!)
    else                                //Здесь кнопка TAMPER находится в нажатом состоянии:
    { GPIOF->BSRRL = indic;             // - вывод 4-разрядного кода в порт F (только разряды с лог. '1')
      Delay_ms(30);                     // - временная задержка
      GPIOF->BSRRH = 0x3C0;             // - вывод логических '1' в разряды 9..6 регистра сброса бит,
                                        //    что соответствует обнулению индикаторных разрядов в порту F
      Delay_ms(30);                     // - временная задержка
    }      

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    //Цикл, постоянно выполняемый при определенном сочетании бит в портах C и G:
    // когда бит PC13 равен 0 и бит PG15 не равен 0 (т.е. нажаты TAMPER и SEL).
    // При каждом проходе осуществляется формирование полного периода сигнала на звуковой излучатель -
    // выдача лог."1", временная задержка на пол-периода, выдача лог."0", временная задержка на пол-периода.
    while (!(GPIOC->IDR & 0x2000) && GPIOG->IDR & 0x8000)
    { GPIOB->BSRRL = 0x02;              // - запись в 1-й разряд регистра установки выходов порта PB (уст. PB1)
      Delay_ms(1);                      // - временная задержка
      GPIOB->BSRRH = 0x02;              // - запись в 1-й разряд регистра сброса выходов порта PB (сброс PB1)
      Delay_ms(1);                      // - временная задержка
    }

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    //Проверка 15-го разряда кода с джойстика (кнопки SEL)
    // При нажатой кнопке при каждом прохождении фрагмента (т.е. циклически) выполняется последовательность:
    // включение каких-то двух индикаторов, временная задержка (задает длительность включенного состояния),
    // гашение индикаторов, временная задержка (задает длительность выключенного состояния).
    // Счетчик на переменной i увеличивается с каждым проходом. Оператор i & 0x8 проверяет состояние
    // 3-го бита счетчика, этот бит изменяется через каждые 2 в степени 3 циклов (т.е. 8 циклов), 
    // соответственно через 8 циклов происходит переключение пар индикаторов. 
    // Оператор i & 0x80 проверяет состояние 7-го бита счетчика, бит изменяется через каждые 2 в степени 7
    // циклов (т.е. 128 циклов), соответственно через 128 циклов изменяется временная задержка, задающая
    // время включенного состояния индикатора. Отношение длительности импульса к периоду определяет 
    // среднюю мощность управления индикаторами (яркость).
    if (joy & 0x8000)                   //Если кнопка нажата, выполняются операции:
    { GPIOF->BSRRL = i & 0x8 ? 0x300    // - в зависимости от состояния счетчика: установка в порту PF
                             : 0xC0;    //    разрядов 9,8 (код 0x300) или 7,6 (код 0xC0)       
      Delay_us(i & 0x80 ? 1000 : 50);   // - в зависимости от состояния счетчика: задание одной из двух задержек
      GPIOF->BSRRH = 0x3C0;             // - запись '1' в разряды 9..6 регистра сброса бит (гашение индикации)
      Delay_ms(10);                     // - фиксированная временная задержка
      i++;                              // - инкремент счетчика (с периодом, примерно равным сумме задержек)
    }

    //Проверка нажатия кнопки WAKEUP, если нажата, сброс процессора (завершение программы)
    if (GPIOA->IDR & 1)  NVIC_SystemReset();
  }

}

//---------------------------------------------------------------------------
// ПОДПРОГРАММА КОНФИГУРИРОВАНИЯ РАЗРЯДА ПОРТА PB1
void PB1_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;                  //Структура конфигурации портов общего назначения

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE); //Разрешение тактирования порта

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;             //Маска на выходной разряд
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;         //Режим: вывод
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;      //Задание быстродействия (2MHz, 25MHz, 50MHz, 100MHz)
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;        //Установка типа выходного каскада: двухтактный
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;      //Подтягивающий резистор: нет 
  GPIO_Init(GPIOB, &GPIO_InitStructure);                //Функция конфигурирования
}

//---------------------------------------------------------------------------
