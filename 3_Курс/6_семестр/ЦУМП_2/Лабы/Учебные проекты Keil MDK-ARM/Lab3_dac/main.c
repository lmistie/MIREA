//---------------------------------------------------------------------------
// 
//  УЧЕБНЫЙ ПРОЕКТ
//  Вывод сигналов с использованием ЦАП и аудиокодека 
//  Copyright (C) 2016 МГТУ МИРЭА
//
//  Формат данных для ЦАП - 12-разрядный смещенный код:
//    код 1111 1111 1111  соответствует Uвых = максимум (практически Vref);
//    код 1000 0000 0000  соответствует Uвых = Vref / 2;
//    код 0000 0000 0000  соответствует Uвых = минимум (практически 0); 
//  где Vref - опорное напряжение (для отладочной платы равно напряжению питания)
//
//  Формат данных для аудиокодека - 16-разрядный дополнительный код,
//  с учетом дополнительного усилителя после аудиокодека: 
//    код 0111 1111 1111 1111  соответствует Uвых = +Um;
//    код 0000 0000 0000 0000  соответствует Uвых = 0;
//    код 1000 0000 0000 0000  соответствует Uвых = -Um;
//  где Um примерно равно 1 В
//
//---------------------------------------------------------------------------

#include "stm32_p407.h"                 //Файл конфигурации отладочной платы STM32-P407
#include "dac.h"                        //Константы и функции для работы с ЦАП
#include "codec.h"                      //Функции для работы с кодеком

//#define DMA_ENA                       //Определение для варианта использования DMA 

uint16_t DACData1, DACData2;            //Данные для ЦАП в смещенном коде
extern int16_t DataChannel1,            //Данные для кодека в дополнительном коде
               DataChannel2;            // (определены в модуле codec.c)

                                        //Таблицы отсчетов сигналов (в смещенном формате)
uint16_t Signal0[] = {  8000,11000,14000,17000,20000,23000,26000,29000,
                       32000,35000,38000,41000,44000,47000,50000,53000 };
uint16_t Signal1[] = { 12000,12000,12000,12000,52000,52000,52000,52000,
                       12000,12000,12000,12000,52000,52000,52000,52000 };
uint16_t Signal2[] = { 22000,32000,42000,52000,52000,52000,52000,52000,
                       42000,32000,22000,12000,12000,12000,12000,12000 };
uint16_t* Signal = Signal0;             //Указатель на одну из таблиц отсчетов

uint16_t index_dac;                     //Индекс отсчета сигнала, выводимого через ЦАП
uint16_t index_codec;                   //Индекс отсчета сигнала, выводимого через кодек
int signal_type;                        //Тип генерируемого сигнала (номер: 0, 1 или 2)

void DMA_DAC_Initialize(void);
void DMA_CODEC_Initialize(void);

//---------------------------------------------------------------------------
// ГЛАВНАЯ ФУНКЦИЯ 
int main()
{
  //Инициализация органов управления в режиме генерации запросов прерывания
  STM_PBInit(BUTTON_WAKEUP, BUTTON_MODE_EXTI);  //Кнопка  WAKEUP
  STM_PBInit(BUTTON_RIGHT, BUTTON_MODE_EXTI);   //Позиции джойстика
  STM_PBInit(BUTTON_LEFT, BUTTON_MODE_EXTI);
  STM_PBInit(BUTTON_UP, BUTTON_MODE_EXTI);

  //Инициализация индикаторов
  STM_LEDInit(LED1); STM_LEDInit(LED2); STM_LEDInit(LED3); STM_LEDInit(LED4);

  //Инициализация ЦАП
  DACInit(16000);                               //Аргумент - частота дискретизации в Гц
#ifndef DMA_ENA  
  DACTimerInterruptConfig(ENABLE);              //Разрешение прерываний от таймера
#else                                           // (в режиме DMA - запрещено)
  DMA_DAC_Initialize();                         //Если задан режим DMA, его инициализация
#endif                                          
  
  //Инициализация кодека
  SoundCodecConfig(I2S_AudioFreq_11k);          //Аргумент - частота дискретизации в Гц
  DMA_CODEC_Initialize();                       //Функция задания режима DMA для кодека

  //Программная генерация запроса прерывания для выбора начального типа сигнала 
  EXTI_GenerateSWInterrupt(EXTI_Line11);
  
  //Цикл в основной программе
  while (1)
  {
    __WFI();                                    //Режим пониженного энергопотребления ("сон")
  }
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ ТАЙМЕРА ТАКТИРОВАНИЯ ЦАП (в режиме DMA не используется)
// Код для передачи в ЦАП - смещенный, выравненный влево.
#ifndef DMA_ENA
void TIMD_IRQHandler(void)
{
  uint16_t DACData;
  STM_LEDOn(LED4);                                    //Отладочная метка (вывод "1")
  if (TIM_GetITStatus(TIMD, TIM_IT_Update) != RESET)  //Проверка источника прерывания
  {
    TIM_ClearITPendingBit(TIMD, TIM_IT_Update);       //Сброс флага запроса прерывания
    switch (signal_type)                              //Ветвление по типу сигнала
    { case 0: DACData = Signal0[index_dac++]; break;  //Загрузка отсчета сигнала из таблицы 
      case 1: DACData = Signal1[index_dac++]; break;  // с автоинкрементом индекса отсчета
      case 2: DACData = Signal2[index_dac++]; break;
    }  
    index_dac &= 0xF;                                 //Приведение индекса к диапазону 0000...1111
    DAC_SetChannel1Data(DAC_Align_12b_L, DACData);    //Передача данных в ЦАП
  }
  STM_LEDOff(LED4);                                   //Отладочная метка (вывод "0")  
}
#endif

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ КОДЕКА
// Выборка отсчета из текущей таблицы, преобразование в дополнительный код,
// загрузка в оба канала, инкремент индекса отсчета с переходом на начало.
void Sample_Handler(void)
{
  DataChannel1 = DataChannel2 = Signal[index_codec++] ^ 0x8000;
  index_codec &= 0xF;
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЙ ОТ ВНЕШНИХ ЛИНИЙ EXTI_Line5...EXTI_Line9
// В нашем случае это линия 6 - разряд порта PG6 (джойстик "вправо"),
//                    линия 7 - разряд порта PG7 (джойстик "вверх").
// Константа EXTI_LineX является маской для соответствующего разряда X.
void EXTI9_5_IRQHandler(void)
{
  if (EXTI_GetITStatus(EXTI_Line6) != RESET)    //Проверка источника прерывания (номера линии)
  {
    EXTI_ClearITPendingBit(EXTI_Line6);         //Сброс флага запроса прерывания
    signal_type = 2;                            //Установка номера нового типа сигнала
    Signal = Signal2;                           //Установка указателя на отсчеты нового сигнала
    STM_LEDOn(LED3);                            //Включение индикатора выбранного типа сигнала
    STM_LEDOff(LED1); STM_LEDOff(LED2);         //Отключение других индикаторов
  }

  if (EXTI_GetITStatus(EXTI_Line7) != RESET)    //Проверка источника прерывания (номера линии)
  {
    EXTI_ClearITPendingBit(EXTI_Line7);         //Сброс флага запроса прерывания
    signal_type = 1;                            //Установка номера нового типа сигнала
    Signal = Signal1;                           //Установка указателя на отсчеты нового сигнала
    STM_LEDOn(LED2);                            //Включение индикатора выбранного типа сигнала
    STM_LEDOff(LED1); STM_LEDOff(LED3);         //Отключение других индикаторов
  }
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЙ ОТ ВНЕШНИХ ЛИНИЙ EXTI_Line10...EXTI_Line15
// В нашем случае это линия 11 - разряд порта PG11 (джойстик "влево")
void EXTI15_10_IRQHandler(void)
{
  if (EXTI_GetITStatus(EXTI_Line11) != RESET)   //Проверка источника прерывания (номера линии)
  {
    EXTI_ClearITPendingBit(EXTI_Line11);        //Сброс флага запроса прерывания
    signal_type = 0;                            //Установка номера нового типа сигнала
    Signal = Signal0;                           //Установка указателя на отсчеты нового сигнала
    STM_LEDOn(LED1);                            //Включение индикатора выбранного типа сигнал
    STM_LEDOff(LED2); STM_LEDOff(LED3);         //Отключение других индикаторов
  }
}

//---------------------------------------------------------------------------
// ОБРАБОТЧИК ПРЕРЫВАНИЯ ОТ ВНЕШНЕЙ ЛИНИИ EXTI_Line0
// К данной линии - разряду порта PA0 - подключена кнопка WAKEUP
void EXTI0_IRQHandler(void)
{
  NVIC_SystemReset();                           //Сброс процессора - завершение программы
}

//---------------------------------------------------------------------------
// ИНИЦИАЛИЗАЦИЯ РЕЖИМА ПРЯМОГО ДОСТУПА К ПАМЯТИ (DMA) ДЛЯ ЦАП
// Обслуживание ЦАП осуществляет контроллер DMA1 с каналами-потоками:
//   DMA1_Stream5 (для DAC1),
//   DMA1_Stream6 (для DAC2).
// Для старта передачи данных необходим запрос по каналу-запросу с номером DMA_Channel_7.
// Для прямой загрузки данных в DAC1 можно использовать регистры (см. stm32f4xx.h):
//   DHR12R1 - 12-битный код с выравниванием вправо
//   DHR12L1 - 12-битный код с выравниванием влево
//   DHR8R1  - 8-битный код с выравниванием вправо
//
void DMA_DAC_Initialize(void)
{
  DMA_InitTypeDef DMA_InitStructure;                                  //Структура конфигурации канала DMA

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);                //Разрешение тактирования контроллера DMA
  DMA_DeInit(DMA1_Stream5);                                           //Начальная установка (сброс) канала
  DMA_InitStructure.DMA_Channel = DMA_Channel_7;                      //Номер источника запроса для канала
  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&DAC->DHR12L1; //Адрес периферийного устройства (регистра ЦАП)
  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&Signal2;         //Адрес буфера памяти (отсчетов сигнала)
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;             //Направление передачи: память -> периферия
  DMA_InitStructure.DMA_BufferSize = sizeof(Signal2) / 2;             //Число транзакций для передачи всего буфера
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;    //Автоувеличение адреса периферии: нет
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;             //Автоувеличение адреса памяти: да
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //Размер транзакции для памяти: полуслово
  DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;     //Размер транзакции для периферии: полуслово
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;                     //Режим передачи буфера: циклический
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;                 //Уровень приоритета: высокий
  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;              //Использование промежуточного FIFO: нет
  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;   //Порог для FIFO (здесь не используется)
  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;         //Размер пакета для памяти: одиночный
  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single; //Размер пакета для периферии: одиночный
  DMA_Init(DMA1_Stream5, &DMA_InitStructure);                         //Функция конфигурирования

  DMA_Cmd(DMA1_Stream5, ENABLE);                                      //Разрешение работы канала DMA

  DAC_DMACmd(DAC_Channel_1, ENABLE);                                  //Разрешение запроса на DMA от ЦАП 1
}

//---------------------------------------------------------------------------
// ИНИЦИАЛИЗАЦИЯ РЕЖИМА ПРЯМОГО ДОСТУПА К ПАМЯТИ ДЛЯ КОДЕКА
// Обслуживание интерфейса SPI3/I2S3, используемого для связи с кодеком,
// осуществляет контроллер DMA1 с каналами-потоками DMA1_Stream5, DMA1_Stream7
// и каналом-запросом DMA_Channel_0 (запрос формируется при пустом буфере передачи).
// Регистр для загрузки данных - SPI3->DR.
// Функция разрешения запроса: SPI_I2S_DMACmd(SPI3, SPI_I2S_DMAReq_Tx, ENABLE);
// Необходимо также обеспечить:
//   - запрет прерываний с частотой дискретизации;
//   - отдельные коды для каждого канала кодека;
//   - коды в дополнительном формате (со знаком).
void DMA_CODEC_Initialize(void)
{
}

//---------------------------------------------------------------------------
